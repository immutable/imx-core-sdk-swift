//
// AssetWithOrders.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct AssetWithOrders: Codable, Hashable {

    public private(set) var collection: CollectionDetails
    /** Timestamp of when the asset was created */
    public private(set) var createdAt: String?
    /** Description of this asset */
    public private(set) var description: String?
    /** Royalties to pay on this asset operations */
    public private(set) var fees: [Fee]?
    /** [DEPRECATED] Internal Immutable X Token ID */
    public private(set) var id: String?
    /** URL of the image which should be used for this asset */
    public private(set) var imageUrl: String?
    /** Metadata of this asset */
    public private(set) var metadata: AnyCodable?
    /** Name of this asset */
    public private(set) var name: String?
    public private(set) var orders: OrderDetails?
    /** Status of this asset (where it is in the system) */
    public private(set) var status: String
    /** Address of the ERC721 contract */
    public private(set) var tokenAddress: String
    /** ERC721 Token ID of this asset */
    public private(set) var tokenId: String
    /** Timestamp of when the asset was updated */
    public private(set) var updatedAt: String?
    /** URI to access this asset externally to Immutable X */
    public private(set) var uri: String?
    /** Ethereum address of the user who owns this asset */
    public private(set) var user: String

    public init(collection: CollectionDetails, createdAt: String?, description: String?, fees: [Fee]? = nil, id: String? = nil, imageUrl: String?, metadata: AnyCodable?, name: String?, orders: OrderDetails? = nil, status: String, tokenAddress: String, tokenId: String, updatedAt: String?, uri: String?, user: String) {
        self.collection = collection
        self.createdAt = createdAt
        self.description = description
        self.fees = fees
        self.id = id
        self.imageUrl = imageUrl
        self.metadata = metadata
        self.name = name
        self.orders = orders
        self.status = status
        self.tokenAddress = tokenAddress
        self.tokenId = tokenId
        self.updatedAt = updatedAt
        self.uri = uri
        self.user = user
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case collection
        case createdAt = "created_at"
        case description
        case fees
        case id
        case imageUrl = "image_url"
        case metadata
        case name
        case orders
        case status
        case tokenAddress = "token_address"
        case tokenId = "token_id"
        case updatedAt = "updated_at"
        case uri
        case user
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(collection, forKey: .collection)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(description, forKey: .description)
        try container.encodeIfPresent(fees, forKey: .fees)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encode(imageUrl, forKey: .imageUrl)
        try container.encode(metadata, forKey: .metadata)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(orders, forKey: .orders)
        try container.encode(status, forKey: .status)
        try container.encode(tokenAddress, forKey: .tokenAddress)
        try container.encode(tokenId, forKey: .tokenId)
        try container.encode(updatedAt, forKey: .updatedAt)
        try container.encode(uri, forKey: .uri)
        try container.encode(user, forKey: .user)
    }
}

